## This script rewrites normal C structs into successively
## greater ones so that field offset computation becomes a
## sizeof lookup and thus amenable to compile-time computations.

## Usage: pipe stg/Regs.h into 'awk' running this script
##        to obtain a .c file that can be compiled to .o
##        with the gcc from the cross toolchain. Then
##        use another 'awk' script to process the 'nm'
##        output of the object file.

## Motivation: since in general we can not run executables
##             created by the cross toolchain, we need another
##             way of finding out field offsets and type sizes
##             of the target platform.

BEGIN {
  interesting = 0
  seed = 0
  print "/* this file is generated by mkDerivedConstants.cross.awk, do not touch */"
  print "/* needs to be compiled with the target gcc */"
  print ""
  print "#include \"Rts.h\""
  print "#include \"Capability.h\""
  print ""
}

## pass through embedded unions
eat_union && /^[ \t]*}[ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t]*;[ \t]*$/ {
  past_members = past_members "\n" $0

  sub(/^[ \t]*}[ \t]*/, "")
  sub(/[ \t]*;[ \t]*$/, "")
  new_offset_struct_name = struct_name $0

  print "struct " new_offset_struct_name " {"
  if (past_members) print past_members

  eat_union = 0
print "//////// GETTING OUT OF UNION"
  print "};"
  print ""
  offset_struct_name = new_offset_struct_name

  print "char sizeof" offset_struct_name "[sizeof(struct " offset_struct_name ")];"
  next
}

eat_union {
  past_members = past_members "\n" $0
  next
}

/# [0-9]* "rts\// {
  ours = 1
  next
}

/# [0-9]* "includes\// {
  ours = 1
  next
}

## filter out non-ghc headers
/# [0-9]* "/ {
  ours = 0
  next
}

!ours {
  next
}


/#if IN_STG_CODE/ {
  nextfile
}

!interesting {
  struct_name = "$" seed "$"
  offset_struct_name = ""
  past_members = ""
  known_struct_name = ""
  eat_union = 0
}

## exclude some complicated ones
/typedef struct StgFunInfoExtraRev_ {/ {
  next
}
/typedef struct StgFunInfoExtraFwd_ {/ {
  next
}
/typedef struct StgInfoTable_ {/ {
  next
}
/typedef struct StgClosure_ {/ {
  next
}
/typedef struct StgTSO_ {/ {
  next
}

## kill comments
/\/\*.*\*\// {
    gsub(/\/\*.*\*\//, "")
}

/\/\/.*$/ {
    sub(/\/\/.*$/, "")
}

## kill empty line
/^[ \t]*$/ {
  next
}

/^# [0-9]/ {
  print
  next
}

/^typedef struct[ \t][ \t]*[_0-9a-zA-Z]*[ \t]*{[ \t]*$/ {
  if (interesting) error "previous struct not closed?"
  interesting = 1
  print ""
  print "/* ### Creating offset structs for " $3 " ### */"
  next
}

/^struct[ \t][ \t]*[_0-9a-zA-Z]*[ \t]*{[ \t]*$/ {
  if (interesting) error "previous struct not closed?"
  interesting = 1
  known_struct_name = $2
  sub(/_$/, "", known_struct_name);
  print ""
  print "/* ### Creating offset structs for " known_struct_name " ### */"
  print "char associate$" known_struct_name "$" seed ";"
  next
}

## end of struct
##
interesting && /^[ \t]*}[ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t]*;[ \t]*$/{
  sub(/;$/, "", $2)

  print "char associate$" $2 "$" seed ";"

  
  print "char SIZEOF" offset_struct_name "[sizeof(" $2 ")];"

  print "typedef char verify" offset_struct_name "[sizeof(struct " offset_struct_name ") == sizeof(" $2 ") ? 1 : -1];"
  print ""
  print ""
  ++seed
  interesting = 0
}

interesting && /^[ \t]*}[; \t]*$/ {
  print "char SIZEOF" offset_struct_name "[sizeof(" known_struct_name ")];"

  # print "typedef char verify" offset_struct_name "[sizeof(struct " offset_struct_name ") == sizeof(" known_struct_name ") ? 1 : -1];"
  print ""
  print ""
  ++seed
  interesting = 0
}

# collapse whitespace after '*'
interesting {
  gsub(/\*[ \t]*volatile/, "*")
  gsub(/\*[ \t]*/, "*")
  sub(/\*/, " *")
  print "//   " $0
  # remove volatile
  sub(/[ \t]volatile[ \t]/, " ")
  # remove const
  sub(/[ \t]const[ \t]/, " ")
}

## (pointer to struct) member of struct
##
interesting && /^[ \t]*struct[ \t][ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t]*\*[ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t]*;[ \t]*$/ {
  if (!$4) {
    sub(/^\*/, "", $3)
    $4 = $3
  }
  sub(/;$/, "", $4)

  new_offset_struct_name = struct_name $4
  print "struct " new_offset_struct_name " {"
  if (past_members) print past_members
  new_member = "  struct " $2 " * " $4 ";"
  print new_member
  if (past_members) {
    past_members = past_members "\n" new_member
  } else {
    past_members = new_member
  }
  print "};"
  print ""
  offset_struct_name = new_offset_struct_name

  print "char sizeof" offset_struct_name "[sizeof(struct " offset_struct_name ")];"
  print ""
  print ""
  next
}

## (simple pointer) member of struct
##
interesting && /^[ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t][ \t]*\*\**[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t]*;[ \t]*$/ {
  sub(/;$/, "", $2)
  sub(/^\**/, "", $2)

  new_offset_struct_name = struct_name $2
  print "struct " new_offset_struct_name " {"
  if (past_members) print past_members
  new_member = "  " $1 " * " $2 ";"
  print new_member
  if (past_members) {
    past_members = past_members "\n" new_member
  } else {
    past_members = new_member
  }
  print "};"
  print ""
  offset_struct_name = new_offset_struct_name

  print "char sizeof" offset_struct_name "[sizeof(struct " offset_struct_name ")];"
  print ""
  print ""
  next
}

## member of struct
##
interesting && /^[ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t][ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*;[ \t]*$/ {
  sub(/;$/, "", $2)

  new_offset_struct_name = struct_name $2
  print "struct " new_offset_struct_name " {"
  if (past_members) print past_members
  new_member = "  " $1 " " $2 ";"
  print new_member
  if (past_members) {
    past_members = past_members "\n" new_member
  } else {
    past_members = new_member
  }
  print "};"
  print ""
  offset_struct_name = new_offset_struct_name

  print "char sizeof" offset_struct_name "[sizeof(struct " offset_struct_name ")];"
  print ""
  print ""
  next
}

## embedded union
interesting && /^[ \t]*union[ \t]*{[ \t]*$/ {
  if (past_members) {
    past_members = past_members "\n" $0
  } else {
    past_members = $0
  }
  eat_union = 1
  next
}

## array member
interesting && /^[ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*[ \t][ \t]*[_0-9a-zA-Z][_0-9a-zA-Z]*\[.*\];[ \t]*$/ {
  sub(/;$/, "", $2)

  full = $2
  split($2, parts, "[")
  $2 = parts[1]

  new_offset_struct_name = struct_name $2
  print "struct " new_offset_struct_name " {"
  if (past_members) print past_members
  new_member = "  " $1 " " full ";"
  print new_member
  if (past_members) {
    past_members = past_members "\n" new_member
  } else {
    past_members = new_member
  }
  print "};"
  print ""
  offset_struct_name = new_offset_struct_name

  print "char sizeof" offset_struct_name "[sizeof(struct " offset_struct_name ")];"
  print ""
  print ""
  next
}
